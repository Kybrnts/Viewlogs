#!/bin/sh
#: Title        : Viewlogs
#: Date         : 2018-02-05
#: Authors      : Written by: "Kybernetes" <correodelkybernetes@gmail.com>
#: Version      : 1.2.0
#: Description  : Executable Dash shell script file.
#:              : Allows user to select and read a log file from a list of allowed directories.
#: Installation : 01. Deploy script in /usr/local/bin/viewlogs
#:              : 02. chown -v root:root /usr/local/bin/viewlogs
#:              : 03. chmod -v 755 /usr/local/bin/viewlogs
#:              : 04. useradd -M -s /usr/local/bin/viewlogs -c "Vew logs user" viewlogs
#:              : 05. setfacl -m u:viewlogs:x /var/log/ # Allow user to "cd" on parent directories
#:              :     setfacl -m u:viewlogs:x /var/
#:              : 06. For each $drctry in /var/log/* that we need to browse ($_LGDIRLST)
#:              :     * chmod -v o+rx "$drctry"                 # Is this even needed?
#:              :     * setfacl -R -m u:viewlogs:rx "$drctry"   # Allow user to browse $path (manage recursively)
#:              :     * setfacl -R -m d:u:viewlogs:rx "$drctry" # New files w/same permissions (default recursively)
##
## -- Configuration globals --------------------------------------------------------------------------------------------
# Allowed extension colon separated list
_FTYPELST="log:txt"
# Allowed-to-read EOL separated directory list
_LGDIRLST="/var/log/tomcat/
/var/log/jboss-as/instance1
/var/log/jboss-as/instance2"
##
## -- Required for execution -------------------------------------------------------------------------------------------
type mkfifo >/dev/null || exit 1   ## Allows temporary fifo creation
type stty >/dev/null || exit 1     ## Get current terminal information
type file >/dev/null || exit 1     ## Get info about files to filter them
type whiptail >/dev/null || exit 1 ## Display user-friendly dialog boxes
type less >/dev/null || exit 1     ## Allow user to browse a given file's content
type tail >/dev/null || exit 1     ## Allow user to follow a text file
##
## -- Globals ----------------------------------------------------------------------------------------------------------
# Declare the following useful symbols:
_RPLY=              ## Read reply
IFS=                ## Clear the IFS in case they a messy one has been exported;
readonly _SPC=" "   ## Space (readonly uses a word for assignment's LHS);
readonly _TAB="	"   ## Tab;
readonly _EOL="
"                   ## En of line (newline);
IFS=$_SPC$_TAB$_EOL ## Now reset de IFS as expected
##
## -- Auxiliary functions ----------------------------------------------------------------------------------------------
stdmsg() { #@ DESCRIPTION: Print messages to STDOUT
           #@ USAGE: stdmsg [ MSG ... ]
    [ "${1+X}" = X ] && printf "%s\n" "$@"
}
errmsg() { #@ DESCRIPTION: Print messages to STDERR prefixed by an error stamp
           #@ USAGE: stderr [ MSG ... ]
    stdmsg ${1+"Error! $@"} >&2
}
setvar() { #@ DESCRIPTION: Sets $1 variable specified by reference, to $2 value. $1 MUST BE A VALID NAME!
           #@ USAGE: setvar NAME [ VALUE ]
           #@        /!\ - WARNING! - /!\ $1 must be a valid name
    eval "$1=\${2+\"\$2\"}" ## Without the right side backslash, escaped chars won't be part of assignment
}
getvar() { #@ DESCRIPTION: Gets value of $2 referenced variable and writes it in $1 referenced name. If referenced
           #@              variable is unset, referenced name will remain unset, and exit status will be 1
           #@ USAGE: getvar NAMEW NAMER
           #@        /!\ - WARNING! - /!\ $1 AND $2 must be a valid names
    eval "[ \"\${$2+X}\" = X ] && $1=\"\${$2}\"" ## Do not set $1 referenced name if $2 is also unset
}
_TFFPTH= _TFFID=0 ## Unique temporary fifo path and ID
_mkTFfo() { #@ DESCRIPTION: Creates unique temporary fifo in /tmp for each invocation during current instance of script
            #@              storing its full path in _TFFPTH global.
            #@ USAGE: _mkTFfo
            #@        DO NOT CALL DIRECTLY, use mkTFfo() wrapper instead.
    ## Local variables (If local is used, it should appear as the first statement of a function)
    local n
    _TFFPTH=/tmp/${0##*/}.$$.$_TFFID.tmp n=0                       ## Initialize fifo's path and an attempts counter
    while ! mkfifo $_TFFPTH 1>/dev/null 2>&1 && [ $n -lt 100 ]; do ## Try create while fifo exists, limiting attempts
        if [ -e $_TFFPTH ]; then                                   ## Fifo already exists in given path?
            _TFFID=$((_TFFID < 999 ? _TFFID + 1 : 0))              ## Yes, increase global ID (reset if limit reached)
            _TFFPTH=/tmp/${0##*/}.$$.$_TFFID.tmp                   ##      and set new path for it
        else                                                       ## No, so assume another problem is present
            errmsg "Failed to create named pipe"                   ## Display error message accordingly
            return 1                                               ## Report this to calling environment
        fi
        n=$((n + 1))                                               ## Increase attempts counter
    done                                                           ## Now sure that fifo was created successfully
    _TFFID=$((_TFFID < 999 ? _TFFID + 1 : 0))                      ## Increase global ID for next invocation
    if [ $n -gt 100 ]; then                                        ## If above loop finished by attempts limit
        errmsg "Too many named pipes"                              ## Assume too many fifos in existence
        return 2                                                   ## Finish w/errors
    fi
}
mkTFfo() { #@ DESCRIPTION: _mkTFfo() Wrapper, that stores unique temporary fifo path in $1 name.
           #@ USAGE: mkTFfo NAME
    _mkTFfo || return $?  ## Create temporary fifo storing full path in global or finish accordingly
    setvar $1 "$_TFFPTH"  ## Now assign global path to referenced name
}
##
## -- Script specific functions ----------------------------------------------------------------------------------------
_LGDIRS= ## Log dirs array size
_getLgDrsArr() { #@ DESCRIPTION: Creates an array-like list of variables with $_LGDIRLST string, storing its size in 
                 #@              above global, and each line in an array element. $1 is used as the array base name.
                 #@ USAGE: _setLgDrsArr ARRAYBASENAME
                 #@        DO NOT CALL DIRECTLY, use setLgDrsArr() wrapper instead.
    ## Local variables (If local is used, it should appear as the first statement of a function)
    local lgdirlst
    lgdirlst="$_LGDIRLST" _LGDIRS=0                    ## Initialize local logs dir list and global array size
    while [ X"$lgdirlst" != X ]; do                    ## While directory string list is not null..
        if [ -d "${lgdirlst%%[$_EOL]*}" ]; then        ## If line/path from string is an existing directory..
            setvar $1_$_LGDIRS "${lgdirlst%%[$_EOL]*}" ## Create array entry w/global size as key and path as value
            _LGDIRS=$((_LGDIRS + 1))                   ## Increase global size
        fi
        case $lgdirlst in                              ## Remove last processed line from global directory list
            *$_EOL*) lgdirlst=${lgdirlst#*$_EOL} ;;    ## If list contains an EOL, remove all up to EOL from front
            *) lgdirlst= ;;                            ## If list doesn't contain EOL assume end of list reached
        esac
    done
}
getLgDrsArr() { #@ DESCRIPTION: Creates an array-like list of variables with $_LGDIRLST string using _getLgDrsArr().
                #@              Array size is stored in $1 and $2 is used as the array base name.
                #@ USAGE: getLgDrsArr NAME ARRAYBASENAME
    _getLgDrsArr ${2+"$2"}                             ## Create the array using $2 name (if present)
    setvar $1 $_LGDIRS                                 ## Assign global array size to referenced name
}
_RGFLS= ## Regular files array size
_getRgFlsArr() { #@ DESCRIPTION: Creates an array-like list of variables w/regular files right under $3 dir. storing
                 #@              each file in an element. Size is stored in global. $1 is used as array's basename.
                 #@ USAGE: _getRgFlsArr ARRAYNAME PATH
                 #@        DO NOT CALL DIRECTLY, use getRgFlsArr wrapper instead.
    ## Local variables (If local is used, it should appear as the first statement of a function)
    local fls tffo ftypelst
    ftypelst="$_FTYPELST" fls=                        ## Initialize local type list and files pattern list
    while [ X"$ftypelst" != X ]; do                   ## While local file type list is not null..
        fls=${fls+"$fls "}"\"\$2\"/*."${ftypelst%%:*} ## For each $type append "$path/*.$type" to files pattern list
        case $ftypelst in                             ## Remove last processed type from types list
            *:*) ftypelst=${ftypelst#*:} ;;           ## If list contains a ':', remove all up to ':' from front
            *) ftypelst= ;;                           ## If it doesn't assume end of list reached
        esac
    done
    if ! mkTFfo tffo; then                            ## Try to create a temporary fifo
        errmsg "Unable to create a temporary pipe"    ## Or fail accordingly
        return 1
    fi
    _RGFLS=0                                          ## Initialize global reg files array size
    eval "printf \"%s\n\" -- $fls" >$tffo &           ## Send path-expanded list of files paths and types to pipe
    { while IFS= read -r _RPLY; do                    ## Read from pipe above file list, line by line
          if [ -f "$_RPLY" ]; then                    ## If line matches existing reg. file..
              setvar $1_$_RGFLS "${_RPLY##*/}"        ## Create array element w/it's file name part
              _RGFLS=$((_RGFLS + 1))                  ## Increase global size
          fi
      done <$tffo; } 2>/dev/null                      ## IO redir for loop to read from pipe and silence shell errors
    if [ $? -gt 1 ]; then                             ## $?=1 when EOF is reached, $?>1 when unable to open fifo
        errmsg "Failed to read from named pipe"       ## Print error message to STDERR when failed to read from pipe
        rm -f $tffo                                   ## Clean up
        return 2                                      ## And finish w/errors
    elif ! wait $!; then                              ## Check exit status from previously backgrounded (job control)
        errmsg "Failed to retrieve regular file list" ## Print error message if backgrounded finished w/errors
        rm -f $tffo                                   ## Clean up
        return 3                                      ## And finish w/errors. We cannot trust what we read from pipe
    fi
    rm -f $tffo                                       ## Clean up before finish
}
getRgFlsArr() { #@ DESCRIPTION: Creates an array-like list of variables w/reg. files right under $3 directory, using $2
                #@ as array's basename, storing each path in arn array elment. Array size is stored in $1 referenced
                #@ name. This is the wrapper to call when _getRgFlsArr() is needed.
    _getRgFlsArr ${2+"$2"} ${3+"$3"} || return $? ## call _getRgFlsArr() or finish preserving its exit status
    setvar $1 $_RGFLS                             ## Store global reg. files array size into $1 referenced name
}
unstArr() { #@ DESCRIPTION: Unset an entire array-like list of variables given its basename and size
            #@ USAGE unsetArr SIZE ARRAYBASENAME
    ## Local variables (If local is used, it should appear as the first statement of a function)
    local i
    i=0                     ## Initialize array index
    while [ $i -le $1 ]; do ## While previous index wasn't the last one
        eval "unset $2_$i"  ## Unset current array element
        i=$((i + 1))        ## Increase index
    done
}
_TROWS= _TCOLS= ## Current terminal's dimensions
_getTrmSze() { #@ DESCRIPTION: Gets current terminal size in rows and columns, storing its values in above globals.
               #@ USAGE: _getTrmSze
               #@        DO NOT CALL DIRECTLY, use getTrmSze() wrapper instead.
    ## Local variables (If local is used, it should appear as the first statement of a function)
    local tffo
    if ! mkTFfo tffo; then                         ## Try to create a temporary fifo
        errmsg "Unable to create a temporary pipe" ## Or fail accordingly
        return 1
    fi
    stty -a >$tffo 2>/dev/null &                   ## Get all current [pseudo]tty information to pipe
    { while IFS= read -r _RPLY; do                 ## Read information line by line
          case $_RPLY in                           ## Filter per line
              *rows*columns*)                      ## If current line contains info about rows and columns
                  _TROWS=${_RPLY#*"rows "}         ## * Extract current rows number to global
                  _TROWS=${_TROWS%%[!0-9]*}        ##
                  _TCOLS=${_RPLY#*"columns "}      ## * Extract current columns number to global
                  _TCOLS=${_TCOLS%%[!0-9]*}        ##
                  break ;;                         ## * Stop reading lines, we got all needed info
          esac
      done <$tffo; } 2>/dev/null                   ## IO redir for loop to read from pipe and silence shell errors
    if [ $? -gt 1 ]; then                          ## $?=1 when EOF is reached, $?>1 when unable to open fifo
        errmsg "Failed to read from named pipe"    ## Print error message to STDERR when failed to read from pipe
        rm -f $tffo                                ## Clean up
        return 2                                   ## And finish w/errors
    elif ! wait $!; then                           ## Check exit status from previously backgrounded (job control)
        errmsg "Failed to get terminal size"       ## Print error message if backgrounded finished w/errors
        rm -f $tffo                                ## Clean up
        return 3                                   ## And finish w/errors. We cannot trust what we read from pipe
    fi
    rm -f $tffo                                    ## Clean finish
}
getTrmSze() { #@ DESCRIPTION: Gets current terminal size in rows and columns using _getTrmSze(), storing them in $1 and
              #@              $2 names respectively.
              #@ USAGE: getTrmSze NAME1 NAME2
    _getTrmSze || return $? ## Call _getTrmSze or finish preserving its exit status
    setvar $1 "$_TROWS"     ## Set referenced names w/global values
    setvar $2 "$_TCOLS"
}
_MSLCTD= ## Option menu selected option value
_menu() { #@ DESCRIPTION: Displays a whiptail option menu using an array-like list of variables. Each array element
          #@              becomes a menu option and each index the corresponding option value. $1 is used as the menu
          #@              title, $2 as a suggestion text, $3 as the array basename $4 as the array length. After user
          #@              chooses an option, its value is written to above's global variable.
          #@ USAGE: _menu TITLE SUGGESTION ARRAYBASENAME ARRAYSIZE [ OK_BUTTON_TEXT [ CANCEL_BUTTON_TEXT ] ]
          #@        DO NOT CALL DIRECTLY, use menu() wrapper instead.
    ## Local variables (If local is used, it should appear as the first statement of a function)
    local rws cls i tgitms itm
    rws=0 cls=0                              ## Initialize rows and columns values
    if ! getTrmSze rws cls; then             ## Get current terminal size in above variables
        errmsg "Unable to get terminal size" ## Or finish w/errors
        return 1
    fi
    i=0 tgitms=                              ## Initialize index and the taged list of items string
    while [ $i -lt $4 ]; do                  ## Turn each array index into a menu tag followed by its matchig element's
        getvar itm $3_$i                     ## double-quoted value, accumulating both into items string.
        tgitms=${tgitms:+"$tgitms "}"$i \"$itm\""
        i=$((i + 1))
    done                                     ## Now display the menu, and await for user's selection
    _MSLCTD=$(eval "whiptail --notags --title \"$1\" --menu \"$2\"\
                             --ok-button \"${5:-OK}\" --cancel-button \"${6:-Cancel}\"\
                             $((rws < 3 ? rws : rws - 3)) $((cls < 30 ? cls : cls - 30))\
                             $((rws < 15 ? rws : rws - 15)) $tgitms x \"${6:-Cancel}\" 3>&1 >&2 2>&3")
    case $? in                               ## If an option is selected, then whiptail's exit status is 0. Else if
        0|1)                                 ## Cancel button is selected it will return 1.
            return $? ;;                     ##
        *)                                   ## In any other case, assume that something wen wrong w/whiptails's exec.
            errmsg "Menu failed"
            return 2 ;;
    esac
}
menu() { #@ DESCRIPTION: This is the wrapper for _menu(), that you generally want to use. In addition to wrapped's
         #@              functionality, it stores the selected item's value in referenced name.
         #@ USAGE: menu NAME TITLE SUGGESTION ARRAYNAME ARRAYSIZE [ OK_BUTTON_TEXT [ CANCEL_BUTTON_TEXT ] ]
    _menu ${2+"$2"} ${3+"$3"} ${4+"$4"} ${5+"$5"} ${6+"$6"} ${7+"$7"} || return $?
    setvar $1 "$_MSLCTD"
}
_RSLCTD=
_radio() { #@ DESCRIPTION: Displays a whiptail radio list that allows user to select between actions to take upon the
           #@               $1 path specified file.
           #@ USAGE: _radio PATH
           #@        DO NOT CALL DIRECTLY, use radio() wrapper instead.
    ## Local variables (If local is used, it should appear as the first statement of a function)
    local rws cls
    rws=0 cls=0                              ## Initialize rows and columns values
    if ! getTrmSze rws cls; then             ## Get current terminal size in above variables
        errmsg "Unable to get terminal size" ## Or finish w/errors
        return 1
    fi                                       ## Now display the radio list awaiting for user to choose
    _RSLCTD=$(whiptail --notags --title "Action select" --radiolist "Select action for $1:"\
                       --ok-button OK --cancel-button Back\
                       $((rws < 20 ? rws : 20)) $((cls < 60 ? cls : 60)) $((rws < 4 ? rws : 4))\
                       1 "View   - less secure " on\
                       2 "Follow - tail -F (rotation aware) " off\
                       3 "Cancel - Go back " off 3>&1 >&2 2>&3)
    case $? in                               ## If an option is selected, then whiptail's exit status is 0. Else if
        0|1)                                 ## Cancel button is selected it will return 1.
            return $? ;;                     ##
        *)                                   ## In any other case, assume that something wen wrong w/whiptails's exec.
            errmsg "Radio failed"
            return 2 ;;
    esac
}
radio() { #@ DESCRIPTION: This is the wrapper for _radio() that you generally want to use. In addition it stores the
          #@              selected item value in $1 referenced name.
          #@ USAGE: radio NAME PATH
    _radio ${2+"$2"} || return $?
    setvar $1 "$_RSLCTD"
}
istxtf() { #@ DESCRIPTION: Tests if $1 path is that of a plain/text file using "file" command. If it is, exit status
           #@ will be 0, otherwise it will be 1. A greater exit status indicates that file itself failed.
           #@ USAGE: istxtf PATH
    ## Local variables (If local is used, it should appear as the first statement of a function)
    local fout
    fout=$(file -i "$1") || return 1               ## Get mime type string or fail
    case $fout in                                  ## Test retreived mime type string
        *inode/x-empty*)                           ## If this is an empty file fail w/specific exit status
            errmsg "$1 is empty."                  ##
            return 2 ;;                            ##
        *text/plain*) return 0 ;;                  ## Else if this is a text file succeed..
        *)                                         ## Fail in any other case w/generic status
            errmsg "$1 is not a plain text file."
            return 3 ;;
    esac
}
viewlog() { #@ DESCRIPTION: Allows user to safely browse $1 text file content.
            #@ USAGE: viewlog PATH
    LESSSECURE=1 less "$1" ## Try to issue less in secure mode
}
fllwlog() { #@ DESCRIPTION: Allows user to follow (monitor) on $1 updates. It is also aware of file rotations. This
            #@              makes it usefull when following for long periods.
            #@ USAGE: fllwlog PATH
    tail -F "$1"               ## Use tail's -F flag to report file rotations to STDOUT
    [ $? -eq 130 ] && return 0 ## Tail seems to exit w/130 when Ctrl+C is issued by user (SIGTERM), hence normal exit
    return 1                   ## Assume failure in any other case
}
##
## -- Main -------------------------------------------------------------------------------------------------------------
main() {
    ## Local variables (If local is used, it should appear as the first statement of a function)
    local ldarr lds s_ld s_ldp lfarr lfs s_lf s_lfp s_rd
    set -m -- ## Force job control ON and discard any positional parameters
    # Check for an interactive shell
    if [ ! -t 0 ]; then                      ## If current STDIN does NOT point to a terminal
        errmsg "Interactive shell required"  ## Finish w/errors
        sleep 3
        return 1
    fi
    # Fetch log-directories-to-select array
    if ! getLgDrsArr lds ldarr; then                     ## Try to get array size in lds using ldarr as array base name
        stdmsg "Unable to retrieve log directory list"   ## When fail to do so, Display an error message
        sleep 3                                          ##                     Allow some time to read the message
        return 2                                         ##                     finish execution w/errors
    fi
    # Script's main loop, keep prompting user to select a directory
    while :; do
        # Request user to select a directory from log directories array
        menu s_ld "Directory selection" "Select a log directory:" \
                  ldarr $lds OK Exit                     ## Display a menu using array elements as options
        case $? in                                       ## Storing selected value in s_ld
            1) return 0 ;;                               ## Finish execution on "Cancel"
            2)                                           ## Also Finish execution w/errors when menu fails
                stdmsg "Unable to get answer from user"
                sleep 3
                return 3 ;;
        esac
        # Take actions according to user selected directory
        case $s_ld in
            [Xx]) return 0 ;;                                   ## If user selected "X" option, finish execution
            *)                                                  ## Else..
                getvar s_ldp ldarr_$s_ld                        ## Get selected array index value path in s_ldp
                if ! getRgFlsArr lfs lfarr "$s_ldp"; then       ## Try Fetch array of files in selected dir path
                   stdmsg "Unable to retrieve $s_ldp file list" ## If fail to do so, display error and finish exec.
                    sleep 3
                    return 4
                fi
                # Keep prompting user to select a log file from selected directory
                while :; do
                    # Request user to select a log file to read
                    menu s_lf "Logfile selection" "Select a log file:" \
                              lfarr $lfs OK Back                ## Display menu using log files array as options
                    case $? in                                  ## Sorting selected value in s_lf
                        1)                                      ## Finish current loop on "Cancel" but make sure to
                            unstArr $lfs lfarr                  ## destroy log files array before next iteration.
                            break ;;
                        2)                                      ## Finish execution w/errors when menu fails
                            stdmsg "Unable to get answer from user"
                            sleep 3
                            return 5 ;;
                    esac
                    # TAke actions according to user selected log file
                    case $s_lf in
                        [Xx])                                  ## If user selected "X" option, finish current loop
                            unstArr $lfs lfarr                 ## Making sure to destroy current log files array
                            break ;;
                        *)                                     ## Else..
                            getvar s_lfp lfarr_$s_lf           ## get selected array index value name in s_lfp
                            if ! istxtf "$s_ldp/$s_lfp"; then  ## Pre-append container's path and test if text file
                                stdmsg "Could not select specified file"
                                sleep 3                        ## Allow user to read why won't display non-text file
                            else                               ## If this is a text file..
                                radio s_rd "$s_lfp"            ## Allow user to choose what to do w/radio item list
                                case $? in                     ## Storing selected item value in s_rd
                                    1) continue ;;             ## Go to previous menu on "Back"
                                    2)                         ## Finish execution on any other exit status (error)
                                        stdmsg "Unable to get answer from user"
                                        sleep 3
                                        return 6 ;;
                                esac
                                # Take action according to user selected action
                                case $s_rd in
                                    1)                                     ## If user selected 1 (view w/less secure)
                                        if ! viewlog "$s_ldp/$s_lfp"; then ## Try to use viewlog to page files's content
                                            stdmsg "Unable to view $s_lfp" ## If above operation fails, display error
                                            sleep 3                        ## Allow user to read above error
                                        fi ;;                              ## Go back to file selection menu
                                    2)                                       ## If user selected 2 (Follow file)
                                        if ! fllwlog "$s_ldp/$s_lfp"; then   ## Try to use fllwlog to follow updates
                                            stdmsg "Unable to follow $s_lfp" ## Or fail going back to file selection
                                            sleep 3
                                        fi ;;                              ## Go back to file selection menu in any
                                esac                                       ## Other case
                            fi ;;
                    esac
                done ;;
        esac
    done
}
##
## -- Run! -------------------------------------------------------------------------------------------------------------
main "$@"
